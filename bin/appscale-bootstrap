#!/usr/bin/env python
# -*- encoding: utf-8 -*-
import os
import time
import sh
import string

from clint.command import Command, run_command
from clint.textui import colored, puts
from sh import ssh

from debgit.branch import get_upstream_for_branch

from appscaletools.ec2 import *

def get_script_url(base, branch, file_path):
    """
    Generate a URL from the given components.

    If the URL happens to be github.com, convert it to raw.github.com
    """

    if '/github.com' in base:
        base = base.replace('github.com', 'raw.github.com')

    return '{0}/{1}{2}'.format(base, branch, file_path)

# EBS-backed AMI so it can be imaged
AMI = 'ami-c7b202ae'

# ec2-run-instances ami-1db20274 -t m1.small --region us-east-1 --key ${EC2_KEYPAIR_US_EAST_1}
EC2_RUN_INSTANCES = sh.Command('ec2-run-instances')

SSH_KEY_NAME = 'EC2_MY_SSH_KEY'
SSH_KEY = os.environ.get('EC2_MY_SSH_KEY')

SSH_ARGS = ('-o', 'UserKnownHostsFile /dev/null', '-o', 'StrictHostKeyChecking no', '-i', SSH_KEY, '-l', 'ubuntu')

CURRENT_BRANCH = os.path.basename(str(sh.git('symbolic-ref', 'HEAD'))).strip()
CURRENT_BRANCH_UPSTREAM = get_upstream_for_branch(CURRENT_BRANCH)

EC2_BOOTSTRAP_SCRIPT = get_script_url(CURRENT_BRANCH_UPSTREAM, CURRENT_BRANCH, '/bootstrap/appscale-bootstrap-ec2')

BOOTSTRAP_DOWNLOADER = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'bootstrap', 'bootstrap_downloader'))


class Bootstrap(Command):
    """
    Bootstrap AppScale on an EC2 environment.

    To install AppScale on an EC2 instance, simply run this command like so:

    appscale-bootstrap

    In the case where there is an error that can be continued from, rerun the
    command specifying the instance that was created in the first run:

    appscale-bootstrap <instance_id>
    """

    def __init__(self, doc=None):
        self.ec2_hostname = None

        super(Bootstrap, self).__init__(doc=doc)

        self.instance_id = None
        self.instance_type = 'm1.small'

        # use the ssh property instead of this directly.
        self._ssh = None

    def _fill_parser(self):
        super(Bootstrap, self)._fill_parser()

        self.parser.add_argument('instance_id', nargs='?', help='The ID of a running instance to provision')

    def _check_ssh_key(self):
        """
        Ensure an SSH key is specified in the environment.

        This is the SSH key that is injected into the VM in order to be able to
        SSH into it.
        """
        if SSH_KEY is None:
            message = (
                "{0} Please set the {1} environment "
                "variable with the SSH key EC2 should use."
            ).format(colored.red('Error:'), colored.yellow(SSH_KEY_NAME))

            raise self.CommandError(message)

    def create_image(self):
        """
        Create an image out of the instance that was just created
        """

        self.logger.debug('create_image')

        ec2_create_image = sh.Command('ec2-create-image')

        for line in ec2_create_image(self.instance_id, _iter=True):
            self.logger.info(line)

    def install_appscale(self):
        """
        SSH into the VM and install AppScale
        """

        tmp_downloader = os.path.join('/tmp', os.path.basename(BOOTSTRAP_DOWNLOADER))
        remote_command = 'cat > {path} && bash {path} {url}'.format(
                path=tmp_downloader, url=EC2_BOOTSTRAP_SCRIPT)

        self.logger.debug('Catting downloader from {0}'.format(BOOTSTRAP_DOWNLOADER))
        self.logger.debug('Remote command: {0}'.format(remote_command))

        # attempt to get an SSH connection up to 5 times because we might try
        # to connect to the machine while it's still trying to boot.
        success = False
        for try_num in range(5):
            try:
                for line in self.ssh(sh.cat(BOOTSTRAP_DOWNLOADER), remote_command, _iter=True):
                    log_line = ''.join(s for s in line.strip() if s in string.printable)
                    self.logger.info(log_line)

                success = True
                break
            except sh.ErrorReturnCode:
                self.logger.error('SSH failure?  Trying again in 5 seconds.')
                time.sleep(5.0)

        if not success:
            raise self.CommandError('Unable to bootstrap instance!')

    @property
    def key_name(self):
        return os.path.basename(SSH_KEY).replace('id_', '')

    def run(self):
        start = time.time()

        self.logger.info('Bootstrapping EC2 instance')

        self._check_ssh_key()

        self.instance_id = self.start_instance()
        self.logger.info('instance id: {0}'.format(self.instance_id))

        self.install_appscale()

        self.stop_instance()

        self.create_image()

        now = time.time()
        elapsed = now - start

        self.logger.info('Done.  Elapsed time: {0}s'.format(elapsed))

    @property
    def ssh(self):
        if self._ssh is not None:
            return self._ssh

        if self.ec2_hostname is None:
            raise self.CommandError('Cannot run SSH without a hostname')

        self._ssh = ssh.bake(SSH_ARGS + (self.ec2_hostname,))
        self.logger.debug('SSH command: {0}'.format(str(self._ssh)))

        return self._ssh

    def start_instance(self):
        """
        Use ec2-run-instances to create a VM on EC2
        """

        instance_id = self.arguments.instance_id
        if instance_id:
            return instance_id

        for line in EC2_RUN_INSTANCES(
                AMI, '-v', '-n', '1', '-t', self.instance_type, '-k', self.key_name, _iter=True):
            matches = EC2_RUN_INSTANCES_RE.match(line)
            if matches:
                instance_id = matches.group('instance_id')

        if instance_id is None:
            raise self.CommandError('Did not find instance id')

        self.wait_for_instance()

        return instance_id

    def stop_instance(self):
        ec2_stop_instances = sh.Command('ec2-stop-instances')
        ec2_stop_instances(self.instance_id)

        self.wait_for_instance(desired_state=EC2_STOPPED_STATE)

    def wait_for_instance(self, desired_state=EC2_RUNNING_STATE):
        """
        Wait for an instance to go from pending to running.

        This will wait a maximum of 5 minutes and error out
        """

        running_state = None
        now = time.time()
        describe_instances_info = None

        while time.time() < now + 300:
            t_running_state = None

            for line in EC2_DESCRIBE_INSTANCES(self.instance_id, _iter=True):
                matches = EC2_DESCRIBE_INSTANCES_RE.match(line)
                if matches:
                    t_running_state = matches.group('running_state')
                    break

            if t_running_state:
                running_state = t_running_state
            else:
                raise self.CommandError('failed to parse ec2-describe-instances output')

            if running_state == desired_state:
                describe_instances_info = matches.groupdict()
                break

            self.logger.debug('instance {0} in {1} state, waiting for {2} state.'.format(
                self.instance_id, running_state, desired_state)
            )

            time.sleep(2.0)

        if running_state != desired_state:
            raise self.CommandError('EC2 instance is in running state {0} instead of {1}'.format(running_state, desired_state))

        # if the machine's state is running, grab the hostname, otherwise clear it
        if running_state == EC2_RUNNING_STATE:
            # set the ec2_hostname from the last regex match
            self.ec2_hostname = describe_instances_info['ec2_hostname']
        else:
            self.ec2_hostname = None


run_command(__name__, Bootstrap)
